using Microsoft.Diagnostics.NETCore.Client;
using Microsoft.Diagnostics.Tracing;
using Microsoft.Diagnostics.Tracing.Parsers;
using Microsoft.Diagnostics.Tracing.Parsers.Clr;
using System.Diagnostics;
using System.Diagnostics.Tracing;
using System.Runtime.InteropServices;
using Windows.Win32;

namespace DotMemoryExplorer.Core {

	internal class EtwHeapDumper : IHeapDumper {

		private readonly LiveDotnetProcess _targetProcess;
		// _isUsed is int because it is used by atmoic (Interlocked) operation which do not support bool
		private int _isUsed = 0;
		private int _gcId = -1;
		private bool _isGcInProgress = false;
		private bool _isDumpCompleted = false;
		private Task? _readerTask = null;
		private DateTime _creationStarted;
		private DateTime _creationCompleted;
		private DateTime _processingCompleted;
		private MemoryDump? _memoryDump = null;

		private readonly List<GCBulkNodeTraceData> _bulkNodes = new List<GCBulkNodeTraceData>();
		private readonly List<GCBulkTypeTraceData> _bulkTypes = new List<GCBulkTypeTraceData>();
		private readonly Queue<GCBulkEdgeTraceData> _bulkEdges = new Queue<GCBulkEdgeTraceData>();
		private DiagnosticsClient? _diagnosticsClient = null;
		private EventPipeSession? _eventSession = null;
		private EventPipeEventSource? _eventSource = null;

		private const string EventProviderId = "Microsoft-Windows-DotNETRuntime";

		public EtwHeapDumper(LiveDotnetProcess liveDotnetProcess) {
			if (liveDotnetProcess == null) {
				throw new ArgumentNullException(nameof(liveDotnetProcess));
			}

			_targetProcess = liveDotnetProcess;
		}

		public HeapDump MakeDump() {
			int originalIsUsed = Interlocked.Exchange(ref _isUsed, 1);
			if (originalIsUsed != 0) {
				throw new InvalidOperationException($"{nameof(EtwHeapDumper)} can make only single dump. Please create new instance before making new dump.");
			}

			// make snapshot of memory
			// _memoryDump = _targetProcess.ProcessMemoryManger.MakeMemoryDump();

			SetupClient();
			LogEvents();
			WaitForCompletion();

			return ConvertEventsToHeapDump();
		}

		private void SetupClient() {
			var runtimeEventProvider = new EventPipeProvider(EventProviderId, EventLevel.Verbose, (long)ClrTraceEventParser.Keywords.GCHeapSnapshot);

			List<EventPipeProvider> providers = new List<EventPipeProvider>();
			providers.Add(runtimeEventProvider);

			_diagnosticsClient = new DiagnosticsClient(_targetProcess.Pid);
			_eventSession = _diagnosticsClient.StartEventPipeSession(runtimeEventProvider, true);
			_eventSource = new EventPipeEventSource(_eventSession.EventStream);

			_eventSource.Clr.GCStart += HandleGcStart;
			_eventSource.Clr.GCStop += HandleGcStop;
			_eventSource.Clr.GCBulkNode += HandleBulkNodeEvent;
			_eventSource.Clr.TypeBulkType += HandleBulkTypeEvent;
			_eventSource.Clr.GCBulkEdge += HandleBulkEdgeEvent;
		}

		private void LogEvents() {
			if (_eventSource == null) {
				// should never happend. Condition is there only for comnpligin with C# non-nullability requirements
				throw new InvalidOperationException($"{_eventSource} is not set yet.");
			}

			_readerTask = Task.Run(() => {
				_eventSource.Process();
			});
		}

		private void WaitForCompletion() {
			if (_readerTask == null) {
				// should never happend. Condition is there only for comnpligin with C# non-nullability requirements
				throw new InvalidOperationException($"{_readerTask} is not set yet.");
			}

			while (!_isDumpCompleted) {
				_readerTask.Wait(100);
			}
		}

		private void HandleGcStart(GCStartTraceData evnt) {
			// there are two cases which we need to handle
			// 1) spurious event from different process
			// 2) nested GCs: In case of using concurent GC mode background GC can be triggered
			//    but we need to collect event full GC triggered by connecting to event pipe and
			//    not the background GC which started at similar time.

			if (evnt.ProcessID != _targetProcess.Pid) {
				// Ignore events generated by different process.
				return;
			}

			if (_isGcInProgress) {
				// loging of GC events is already in progress. No need to start it again.
				// Most probably spurious event.
				return;
			}

			if (evnt.Type == GCType.BackgroundGC) {
				// We are interested in events from full GC. Not the background (concurent) one.
				return;
			}

			// at begining copy memory content
			_memoryDump = _targetProcess.ProcessMemoryManger.MakeMemoryDump();

			// save GC id for detecting that GC which we are insterested in completed (checked in HandleGcStop)
			_gcId = evnt.Count;
			_isGcInProgress = true;
			_creationStarted = DateTime.Now;
		}


		private void HandleGcStop(GCEndTraceData evnt) {
			if (evnt.ProcessID != _targetProcess.Pid) {
				// Ignore events generated by different process.
				return;
			}

			if (!_isGcInProgress || evnt.Count != _gcId) {
				// different (most probably background) GC ended but we still wait to correct one.
				return;
			}

			_eventSource?.StopProcessing();
			_isGcInProgress = false;
			_isDumpCompleted = true;
			_creationCompleted = DateTime.Now;
		}

		private void HandleBulkNodeEvent(GCBulkNodeTraceData obj) {
			if (obj.ProcessID != _targetProcess.Pid) {
				// Ignore events generated by different process.
				return;
			}

			if (!_isGcInProgress) {
				// Ignore events until GC starts.
				return;
			}

			_bulkNodes.Add((GCBulkNodeTraceData)obj.Clone());
		}

		private void HandleBulkTypeEvent(GCBulkTypeTraceData obj) {
			if (obj.ProcessID != _targetProcess.Pid) {
				// Ignore events generated by different process.
				return;
			}

			if (!_isGcInProgress) {
				// Ignore events until GC starts.
				return;
			}

			_bulkTypes.Add((GCBulkTypeTraceData)obj.Clone());
		}

		private void HandleBulkEdgeEvent(GCBulkEdgeTraceData obj) {
			if (obj.ProcessID != _targetProcess.Pid) {
				// Ignore events generated by different process.
				return;
			}

			if (!_isGcInProgress) {
				// Ignore events until GC starts.
				return;
			}

			_bulkEdges.Enqueue((GCBulkEdgeTraceData)obj.Clone());
		}

		private HeapDump ConvertEventsToHeapDump() {
			if (_memoryDump == null) {
				throw new Exception("Memory dump is not created yet.");
			}

			EtwHeapBuilder heapBuilder = new EtwHeapBuilder(_bulkTypes, _bulkNodes, _bulkEdges, _memoryDump, _targetProcess);
			HeapDump heap = heapBuilder.Build();
			_processingCompleted = DateTime.Now;
			heap.SetTimeMarks(_creationStarted, _creationCompleted, _processingCompleted);
			heap.SetStatistics(heapBuilder.ObjectsCount, heapBuilder.ReferencesCount);
			return heap;
		}

		public void Dispose() {
			_eventSession?.Dispose();
			_eventSource?.Dispose();
		}

	}
}